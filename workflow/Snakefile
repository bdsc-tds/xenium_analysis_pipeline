from typing import Any
import os
import shutil
import json
include: "scripts/utils/config_utils.py"
include: "scripts/utils/raw_data_utils.py"
include: "scripts/utils/run_time_utils.py"

# Ensure that only one configuration file is used.
if len(workflow.configfiles) > 1:
    raise RuntimeError(f"Error! At most one configuration file is allowed to be passed via command line options, but {len(workflow.configfiles)} are detected.")
elif len(workflow.configfiles) == 0:
    configfile: 'config/config.yml'
assert len(workflow.configfiles) == 1

process_config(
    config,
    root_path=os.path.dirname(
        os.path.normpath(
            os.path.abspath(
                workflow.configfiles[0]
            )
        )
    )
)


#######################################
#             Local rules             #
#######################################

localrules: all


#######################################
#              Wildcards              #
#######################################

import config_constants as cc


"""
Explanation of wildcards:
- sample_id: The name of an sample to be processed with a format of "disease/gene_panel/donor/sample".
- segmentation_id: The name of a segmentation method to be used.
- annotation_id: The name of cell-type annotation to be used in a format "approach/reference_type/method/level/mode". E.g., "reference_based/matched_reference/rctd/Level3/single_cell".
"""

SAMPLE_ID = get_dict_value(
    config,
    cc.WILDCARDS_NAME,
    cc.WILDCARDS_SAMPLES_NAME
)
SEGMENTATION_ID = get_dict_value(
    config,
    cc.WILDCARDS_NAME,
    cc.WILDCARDS_SEGMENTATION_NAME
)
ANNOTATION_ID = [j for i in get_dict_value(
    config,
    cc.WILDCARDS_NAME,
    cc.WILDCARDS_CELL_TYPE_ANNOTATION_NAME
).values() for j in i]

wildcard_constraints:
    sample_id='|'.join([re.escape(i) for i in SAMPLE_ID]),
    segmentation_id='|'.join([re.escape(i) for i in SEGMENTATION_ID]),
    annotation_id='|'.join([re.escape(i) for i in ANNOTATION_ID])


########################################
#           Predefined rules           #
########################################

include: 'rules/reprocess_raw_data.smk'
include: 'rules/segmentation.smk'
include: 'rules/standard_seurat_analysis.smk'
include: 'rules/cell_type_annotation.smk'


#######################################
#              Functions              #
#######################################

def get_output4reports() -> list[str]:
    prefix: str = f'{config["output_path"]}/segmentation'
    ret: list[str] = []

    ret.extend(
        [
            os.path.join(
                prefix,
                i,
                j,
                "reports",
                "standard_seurat_analysis.html"
            ) for i in SEGMENTATION_ID for j in SAMPLE_ID

        ]
    )

    return ret

def get_output4cleanup() -> list[str]:
    ret: list[str] = []

    # Get the path to the raw data, and save it if it is reprocessed.
    for i in SAMPLE_ID:
        use_raw_data, _ret = get_raw_data_dir(i)
        if not use_raw_data:
            ret.append(
                os.path.join(
                    _ret,
                    "_auxiliary_files.tar"
                )
            )

    # Get the path to the normalised results from all segmentation methods.
    seg_prefix: str = f'{config["output_path"]}/segmentation'
    ret.extend(
        [
            os.path.join(
                seg_prefix,
                i,
                j,
                "normalised_results",
                "_auxiliary_files.tar"
            ) for i in SEGMENTATION_ID for j in SAMPLE_ID

        ]
    )

    # Clean up the Segger results.
    if "segger" in SEGMENTATION_ID:

        # Get the path to the preprocessed data from Segger.
        segger_prefix: str = f'{config["output_path"]}/segmentation/segger'
        ret.extend(
            [
                os.path.join(
                    segger_prefix,
                    i,
                    "preprocessed_data",
                    "tiles.tgz",
                ) for i in SAMPLE_ID
            ]
        )

    return ret

def get_output4cell_type_annotation() -> list[str]:
    prefix: str = f'{config["output_path"]}/segmentation'
    filenames: list[str] = ["output.rds", "labels.csv", "scores.csv"]

    samples_by_disease: dict[str, list[str]] = get_dict_value(
        config,
        "experiments",
        cc.EXPERIMENTS_COLLECTIONS_NAME,
        cc.EXPERIMENTS_COLLECTIONS_DISEASES_NAME
    )

    annotation_by_disease: dict[str, list[str]] = get_dict_value(
        config,
        cc.WILDCARDS_NAME,
        cc.WILDCARDS_CELL_TYPE_ANNOTATION_NAME
    )

    samples_annotation: list[list[str]] = cross_samples_annotation_by_disease(
        samples_by_disease,
        annotation_by_disease
    )

    return [os.path.join(
        prefix,
        i,
        j[0],
        "cell_type_annotation",
        j[1],
        k
    ) for i in SEGMENTATION_ID for j in samples_annotation for k in filenames]

def get_input2all(
    wildcards,
    *,
    reports: bool = True,
    cleanup: bool = False,
    cell_type_annotation: bool = True
) -> list[str]:
    ret: list[str] = []

    if reports:
        ret.extend(get_output4reports())

    if cleanup:
        ret.extend(get_output4cleanup())

    if cell_type_annotation:
        ret.extend(get_output4cell_type_annotation())
    
    return ret


#######################################
#                Rules                #
#######################################

rule all:
    input:
        lambda wildcards: get_input2all(
            wildcards,
            reports=True,
            cleanup=False
        )
