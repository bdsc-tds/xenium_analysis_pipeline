#######################################
#              Functions              #
#######################################

def get_input2_or_params4runResolvi(wildcards, for_input: bool = True) -> str | list[str]:
    prefix: str = f'{config["output_path"]}/segmentation'
    ret: str = ""

    if wildcards.compact_segmentation_id == "10x_0um":
        ret = os.path.join(
            prefix,
            f"10x_0um/{wildcards.sample_id}/normalised_results",
        )

        if not for_input:
            ret = normalise_path(
                ret,
                candidate_paths=("outs",),
                pat_anchor_file=r"transcripts\.parquet",
                pat_flags=re.IGNORECASE,
                return_dir=True,
                check_exist=False
            )
    elif wildcards.compact_segmentation_id == "proseg":
        ret = os.path.join(
            prefix,
            f'proseg/{wildcards.sample_id}/raw_results'
        )

        if for_input:
            ret = [
                os.path.join(
                    ret,
                    i
                ) for i in [
                    "cell-metadata.csv.gz",
                    "transcript-metadata.csv.gz",
                    "cell-polygons.geojson.gz",
                    "expected-counts.csv.gz"
                ]
            ]
    else:
        raise RuntimeError(f"Error! Cannot run Ovrlpy on samples generated by unknown segmentation method: {wildcards.compact_segmentation_id}.")

    return ret


#######################################
#                Rules                #
#######################################

rule runResolvi:
    input:
        get_input2_or_params4runResolvi
    output:
        corrected_counts=protected(f'{config["output_path"]}/count_correction/{wildcards.compact_segmentation_id}/{wildcards.sample_id}/resolvi/corrected_counts.h5'),
        proportions=protected(f'{config["output_path"]}/count_correction/{wildcards.compact_segmentation_id}/{wildcards.sample_id}/resolvi/proportions.parquet')
    params:
        input_data=lambda wildcards: get_input2_or_params4runResolvi(
            wildcards,
            for_input=False,
        ),
        num_samples=get_dict_value(
            config,
            "count_correction",
            "resolvi",
            "num_samples",
            replace_none=100,
        ),
        min_counts=lambda wildcards: get_dict_value(
            config,
            "experiments",
            cc.EXPERIMENTS_GENE_PANEL_QC_NAME,
            extract_layers_from_experiments(wildcards.sample_id, [0, 1])[0],
            "min_counts",
            replace_none=get_dict_value(
                config,
                "standard_seurat_analysis",
                "qc",
                "min_counts",
                replace_none=10
            ),
            inexist_key_ok=True
        ),
        min_features=lambda wildcards: get_dict_value(
            config,
            "experiments",
            cc.EXPERIMENTS_GENE_PANEL_QC_NAME,
            extract_layers_from_experiments(wildcards.sample_id, [0, 1])[0],
            "min_features",
            replace_none=get_dict_value(
                config,
                "standard_seurat_analysis",
                "qc",
                "min_features",
                replace_none=5
            ),
            inexist_key_ok=True
        ),
        max_counts=lambda wildcards: float(get_dict_value(
            config,
            "experiments",
            cc.EXPERIMENTS_GENE_PANEL_QC_NAME,
            extract_layers_from_experiments(wildcards.sample_id, [0, 1])[0],
            "max_counts",
            replace_none=get_dict_value(
                config,
                "standard_seurat_analysis",
                "qc",
                "max_counts",
                replace_none="Inf"
            ),
            inexist_key_ok=True
        )),
        max_features=lambda wildcards: float(get_dict_value(
            config,
            "experiments",
            cc.EXPERIMENTS_GENE_PANEL_QC_NAME,
            extract_layers_from_experiments(wildcards.sample_id, [0, 1])[0],
            "max_features",
            replace_none=get_dict_value(
                config,
                "standard_seurat_analysis",
                "qc",
                "max_features",
                replace_none="Inf"
            ),
            inexist_key_ok=True
        )),
        min_cells=lambda wildcards: get_dict_value(
            config,
            "experiments",
            cc.EXPERIMENTS_GENE_PANEL_QC_NAME,
            extract_layers_from_experiments(wildcards.sample_id, [0, 1])[0],
            "min_cells",
            replace_none=get_dict_value(
                config,
                "standard_seurat_analysis",
                "qc",
                "min_cells",
                replace_none=5
            ),
            inexist_key_ok=True
        )
    log:
        f'{config["output_path"]}/count_correction/{wildcards.compact_segmentation_id}/{wildcards.sample_id}/resolvi/logs/runResolvi.log'
    wildcard_constraints:
        compact_segmentation_id=r"10x_0um|proseg"
    container:
        config["containers"]["r"]
    conda:
        "../../envs/general.yml"
    resources:
        mem_mb=lambda wildcards, attempt: min(
            get_size(
                get_input2_or_params4runOvrlpy(
                    wildcards,
                    for_input=False
                )
            ) * 1e-6 * attempt**3 * 100,
            1024000
        ),
        slurm_partition=lambda wildcards: get_slurm_gpu_partition_name(
            wildcards,
        ) if _use_gpu() else "cpu",
        slurm_extra=get_slurm_extra
    shell:
        "python workflow/scripts/xenium/resolvi_sample.py "
        "--path {input.path} "
        "--out_file_resolvi_corrected_counts {output.out_file_resolvi_corrected_counts} "
        "--out_file_resolvi_proportions {output.out_file_resolvi_proportions} "
        "--min_counts {params.min_counts} "
        "--min_features {params.min_features} "
        "--max_counts {params.max_counts} "
        "--max_features {params.max_features} "
        "--min_cells {params.min_cells} "
        "--num_samples {params.num_samples} "
        "-l {log}"
